<!DOCTYPE html>
<html>
<head>
  <title>Foxhole Inventory Report</title>
  <meta charset="utf-8" />
  <link rel="icon" href="favicon.ico" type="image/x-icon" />

  <style>
    li { line-height: 1.25; }
    input { display: block; }

    div.render {
      display: flex;
      flex-flow: column wrap;
      height: 1024px;
      margin-bottom: 200px;
      
      font: 26px Arial;
      color: #ed2121;
      background-color: #111;

      overflow-x: auto;
      resize: vertical;
    }

    div.render > div {
      display: block;
      padding: 8px;
    }
    div.render > div > span {
      display: inline-block;
      padding: 4px 0;
    }
    div.render > div > img { display: block; }
  </style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.0/html2canvas.min.js" integrity="sha512-UcDEnmFoMh0dYHu0wGsf5SKB7z7i5j3GuXHCnb3i4s44hfctoLihr896bxM0zL7jGkcHQXXrJsFIL62ehtd6yQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script>
    'use strict';

    // These parameters tune the detection of inventory boxes
    const MIN_INVENTORY_WIDTH = 100;
    const MIN_CORNER_LIGHT = 5; // out of 7
    const MIN_CORNER_DARK = 6; // out of 6

    const MAX_DARK_CHANNEL_VARIANCE = 16;
    const MAX_DARK_PIXEL_VALUE = 32;

    const MAX_GREY_CHANNEL_VARIANCE = 5;
    const MAX_GREY_PIXEL_VARIANCE = 8;
    const IDEAL_GREY_VALUE = 131;

    const MAX_MERGE_VARIANCE = 3;

    var imagesProcessed = 0;
    var imagesTotal = 0;

    addEventListener('DOMContentLoaded', function() {
      const input = document.querySelector('form input');
      const download = document.querySelector('button');

      document.querySelector('form').addEventListener('submit', function(e) {
        // Prevent a submit that would lose our work
        e.preventDefault();
      });

      input.addEventListener('change', function() {
        const collage = document.querySelector('div.render');
        collage.innerHTML = '';

        imagesProcessed = 0;
        imagesTotal = input.files.length;
        document.querySelector('li span').textContent = imagesProcessed + " of " + imagesTotal;

        const files = Array.from(input.files).sort(function(a, b) {
          // Consistent ordering based on when each screenshot was captured
          return a.lastModified - b.lastModified;
        });

        files.forEach(function(file) {
          const container = document.createElement('div');
          const label = document.createElement('span');
          label.textContent = file.name;
          label.contentEditable = true;
          label.spellcheck = false;
          container.appendChild(label);

          const image = document.createElement('img');
          image.style.display = 'none';
          image.addEventListener('load', cropImage);
          image.src = URL.createObjectURL(file);
          container.appendChild(image);

          collage.appendChild(container);
        });
      });

      download.addEventListener('click', function() {
        const collage = document.querySelector('div.render');
        html2canvas(collage, {
          width: collage.scrollWidth,
          height: collage.scrollHeight,
          windowWidth: collage.scrollWidth + 16,
          windowHeight: collage.scrollHeight + 16,
        }).then(function(canvas) {
          var link = document.createElement('a');
          link.href = canvas.toDataURL();

          var time = new Date();
          link.download = time.toISOString() + "_" + 'foxhole-inventory.png';

          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        });
      });
    });

    function cropImage() {
      this.removeEventListener('load', cropImage);

      // Cache width and height as these are very expensive to read
      const width = this.width;
      const height = this.height;

      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');

      canvas.width = width;
      canvas.height = height;
      context.drawImage(this, 0, 0);

      const pixels = context.getImageData(0, 0, width, height).data;
      var boxes = [];

      var darkCount = 0;
      for (var row = 0; row < height; ++row) {
        for (var col = 0; col < width; ++col) {
          const redIndex = calcRedIndex(row, col, width);
          if (isDark(pixels[redIndex], pixels[redIndex+1], pixels[redIndex+2])) {
            ++darkCount;
          } else if (darkCount >= MIN_INVENTORY_WIDTH) {
            var box = {
              right: col - 1,
              bottom: row,
              left: col - darkCount,
            };

            if (checkRightCorner(pixels, box.bottom, box.right, width) &&
                  checkLeftCorner(pixels, box.bottom, box.left, width)) {
              box.top = findTop(pixels, box.bottom, Math.round(box.right - darkCount / 2), width);

              // Inventory windows can't start at the top
              if (box.top > 0) {
                var leftOffset = Math.abs((box.right - box.left) - width / 2);
                var topOffset = Math.abs((box.bottom - box.top) - height / 2);
                box.middleOffset = Math.sqrt(leftOffset * leftOffset + topOffset * topOffset);
                boxes.push(box);
              }
            }

            darkCount = 0;
          } else {
            darkCount = 0;
          }
        }
      }

      if (boxes.length) {
        // Prefer the box closest to the middle
        boxes.sort((a, b) => a.middleOffset - b.middleOffset);
        var box = boxes[0];

        // Prefer tallest box with similar left and right
        boxes = boxes.filter(function(a) {
          return Math.abs(a.left - box.left) <= MAX_MERGE_VARIANCE &&
            Math.abs(a.right - box.right) <= MAX_MERGE_VARIANCE
        });
        boxes.sort((a, b) => (b.bottom - b.top) - (a.bottom - a.top));
        box = boxes[0];

        const cropped = document.createElement('canvas');
        const croppedWidth = box.right - box.left;
        const croppedHeight = box.bottom - box.top;

        cropped.width = croppedWidth;
        cropped.height = croppedHeight;
        cropped.getContext("2d").drawImage(canvas,
            box.left, box.top, croppedWidth, croppedHeight,
            0, 0, croppedWidth, croppedHeight);
        this.src = cropped.toDataURL();
      }

      this.style.display = '';
      ++imagesProcessed;
      document.querySelector('li span').textContent = imagesProcessed + " of " + imagesTotal;
    }

    function checkRightCorner(pixels, row, col, width) {
      var darkCornerCount = 0;
      for (var darkRow = row - 2; darkRow < row; ++darkRow) {
        for (var darkCol = col - 2; darkCol <= col; ++darkCol) {
          const darkRedIdx = calcRedIndex(darkRow, darkCol, width);
          if (isDark(pixels[darkRedIdx], pixels[darkRedIdx+1], pixels[darkRedIdx+2])) {
            ++darkCornerCount;
          }
        }
      }

      var lightCornerCount = 0;
      var lightCol = col + 1;
      for (var lightRow = row - 2; lightRow <= row + 1; ++lightRow) {
        const lightRedIdx = calcRedIndex(lightRow, lightCol, width);
        if (!isDark(pixels[lightRedIdx], pixels[lightRedIdx+1], pixels[lightRedIdx+2])) {
          ++lightCornerCount;
        }
      }

      lightRow = row + 1;
      for (lightCol = col - 2; lightCol <= col; ++lightCol) {
        const lightRedIdx = calcRedIndex(lightRow, lightCol, width);
        if (!isDark(pixels[lightRedIdx], pixels[lightRedIdx+1], pixels[lightRedIdx+2])) {
          ++lightCornerCount;
        }
      }

      return (darkCornerCount >= MIN_CORNER_DARK) &&
        (lightCornerCount >= MIN_CORNER_LIGHT);
    }

    function checkLeftCorner(pixels, row, col, width) {
      var darkCornerCount = 0;
      for (var darkRow = row - 2; darkRow < row; ++darkRow) {
        for (var darkCol = col; darkCol <= col + 2; ++darkCol) {
          const darkRedIdx = calcRedIndex(darkRow, darkCol, width);
          if (isDark(pixels[darkRedIdx], pixels[darkRedIdx+1], pixels[darkRedIdx+2])) {
            ++darkCornerCount;
          }
        }
      }

      var lightCornerCount = 0;
      var lightCol = col - 1;
      for (var lightRow = row - 2; lightRow <= row + 1; ++lightRow) {
        const lightRedIdx = calcRedIndex(lightRow, lightCol, width);
        if (!isDark(pixels[lightRedIdx], pixels[lightRedIdx+1], pixels[lightRedIdx+2])) {
          ++lightCornerCount;
        }
      }

      lightRow = row + 1;
      for (lightCol = col; lightCol <= col + 2; ++lightCol) {
        const lightRedIdx = calcRedIndex(lightRow, lightCol, width);
        if (!isDark(pixels[lightRedIdx], pixels[lightRedIdx+1], pixels[lightRedIdx+2])) {
          ++lightCornerCount;
        }
      }

      return (darkCornerCount >= MIN_CORNER_DARK) &&
        (lightCornerCount >= MIN_CORNER_LIGHT);
    }

    function findTop(pixels, row, col, width) {
      var checkRow = row - 1;
      var foundGrey = false;
      while (checkRow > 0) {
        var lightRedIdx = calcRedIndex(checkRow, col, width);
        if (foundGrey && isLight(pixels[lightRedIdx], pixels[lightRedIdx+1], pixels[lightRedIdx+2])) {
          break;
        } else if (isGrey(pixels[lightRedIdx], pixels[lightRedIdx+1], pixels[lightRedIdx+2])) {
          foundGrey = true;
        } else {
          foundGrey = false;
        }
        --checkRow;
      }
      return checkRow;
    }

    function calcRedIndex(row, col, width) {
      // Assumes RGBA packing
      return (col * 4) + (row * width * 4);
    }

    function isDark(r, g, b) {
      var avg = (r + g + b) / 3;
      return (Math.abs(avg - r) < MAX_DARK_CHANNEL_VARIANCE) &&
        (Math.abs(avg - g) < MAX_DARK_CHANNEL_VARIANCE) &&
        (Math.abs(avg - b) < MAX_DARK_CHANNEL_VARIANCE) &&
        (avg < MAX_DARK_PIXEL_VALUE);
    }

    function isGrey(r, g, b) {
      var avg = (r + g + b) / 3;
      return (Math.abs(avg - r) < MAX_GREY_CHANNEL_VARIANCE) &&
        (Math.abs(avg - g) < MAX_GREY_CHANNEL_VARIANCE) &&
        (Math.abs(avg - b) < MAX_GREY_CHANNEL_VARIANCE) &&
        (Math.abs(avg - IDEAL_GREY_VALUE) < MAX_GREY_PIXEL_VARIANCE);
    }

    function isLight(r, g, b) {
      return !isDark(r, g, b) && !isGrey(r, g, b);
    }
  </script>
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-C3TZNS69Y1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-C3TZNS69Y1');
  </script>
</head>
<body>
  <h2>Foxhole Inventory Report</h2>
  <ol>
    <li>Screenshot multiple inventories from the map view in-game.  Do this in the order you'd like them to appear in the report.</li>
    <li>
      <form>
        <label>Select map screenshots: 
          <input accept="image/*" type="file" multiple>
        </label>
      </form>
    </li>
    <li>Wait for processing to complete.
      <div>Processed: <span>0 of 0</span></div>
    </li>
    <li>Edit the red titles by clicking on them.</li>
    <li><button>Download result</button></li>
  </ol>
  <div class="render"></div>
</body>
</html>
